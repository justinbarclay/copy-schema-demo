#+PROPERTY: header-args:sql :engine "postgresql" :dbuser postgres :dbpassword "123456" :database sample_app_default :dbhost localhost

#+BEGIN_QUOTE
If you want to get the most out of this, you should run this document interactively. If you would like to follow along, open up your version Emacs, move your cursor to a code block, then press ~C-c C-c~ to run it.
#+END_QUOTE

* How I sped up demo data generation by 97%
** ...or how I chose to copy data instead of generating it
TLDR; Move from ruby and rails to SQL

#+CAPTION: Women with a surprised face
#+NAME: Colour me surprised
[[https://www.publicdomainpictures.net/pictures/20000/velka/surprise-surprise.jpg]]
* Why work on this?
:PROPERTIES:
:HEADER: hidden
:END:

For a project I was working on, it would take close to 12 minutes to gather and generate the data needed for demoing and testing the application. This means each time we would want to reset the application to it's initial state, for demo purposes, it would take us 12 minutes.

Look, mistakes were made, OK? But I am trying to learn (out in the open) from them. And, in this case, I'm looking to take you along this specifically painful journey.
* Using Pure SQL to Copy
When I started this adventure, I knew very little about SQL and less so the variant we use, PSQL. I knew enough to write some select statements and maybe do a join. Did you know you could write full-on programs in it? It's even Turing complete! ðŸ¤¯ It's not pretty, but it works.

I had a pretty good idea of what I wanted to do from a high level. We want to use a schema, called ~demo~, to cache any demo data generation. Then, when we want to populate an account schema with demo data, we copy data from the ~demo~ schema into the client schema.

Simple, but I had no clue how to do this. I had no clue about the metaprogramming possible in PSQL. So, I did what every good developer does. Go to StackOverflow.

That led me on a short journey onto the [[https://wiki.postgresql.org/wiki/Clone_schema][PostgreSQL wiki]] on how to clone tables from one schema onto another schema. Close but it has nothing about cloning the data or metadata about those tables.

This wiki links to a more complete [[https://www.postgresql.org/message-id/CANu8FiyJtt-0q%3DbkUxyra66tHi6FFzgU8TqVR2aahseCBDDntA%40mail.gmail.com ][mailing list post]] that goes over how to copy all the data from a source schema into a brand new schema.

#+begin_src sql
  -- Function: clone_schema(text, text)

  -- DROP FUNCTION clone_schema(text, text);

  CREATE OR REPLACE FUNCTION clone_schema(
      source_schema text,
      dest_schema text,
      include_recs boolean)
    RETURNS void AS
  $BODY$

  --  This function will clone all sequences, tables, data, views & functions from any existing schema to a new one
  -- SAMPLE CALL:
  -- SELECT clone_schema('public', 'new_schema', TRUE);

  DECLARE
    src_oid          oid;
    tbl_oid          oid;
    func_oid         oid;
    object           text;
    buffer           text;
    srctbl           text;
    default_         text;
    column_          text;
    qry              text;
    dest_qry         text;
    v_def            text;
    seqval           bigint;
    sq_last_value    bigint;
    sq_max_value     bigint;
    sq_start_value   bigint;
    sq_increment_by  bigint;
    sq_min_value     bigint;
    sq_cache_value   bigint;
    sq_log_cnt       bigint;
    sq_is_called     boolean;
    sq_is_cycled     boolean;
    sq_cycled        char(10);
  BEGIN

  -- Check that source_schema exists
    SELECT oid INTO src_oid
      FROM pg_namespace
     WHERE nspname = quote_ident(source_schema);
    IF NOT FOUND
      THEN 
      RAISE NOTICE 'source schema % does not exist!', source_schema;
      RETURN ;
        END IF;

    -- Check that dest_schema does not yet exist
    PERFORM nspname 
      FROM pg_namespace
     WHERE nspname = quote_ident(dest_schema);
    IF FOUND
      THEN 
      RAISE NOTICE 'dest schema % already exists!', dest_schema;
      RETURN ;
    END IF;

    EXECUTE 'CREATE SCHEMA ' || quote_ident(dest_schema) ;

    -- Create sequences
    -- TODO: Find a way to make this sequence's owner is the correct table.
    FOR object IN
      SELECT sequence_name::text 
        FROM information_schema.sequences
        WHERE sequence_schema = quote_ident(source_schema)
    LOOP
      EXECUTE 'CREATE SEQUENCE ' || quote_ident(dest_schema) || '.' || quote_ident(object);
      srctbl := quote_ident(source_schema) || '.' || quote_ident(object);

      EXECUTE 'SELECT last_value, max_value, start_value, increment_by, min_value, cache_value, log_cnt, is_cycled, is_called 
                FROM ' || quote_ident(source_schema) || '.' || quote_ident(object) || ';' 
                INTO sq_last_value, sq_max_value, sq_start_value, sq_increment_by, sq_min_value, sq_cache_value, sq_log_cnt, sq_is_cycled, sq_is_called ; 

      IF sq_is_cycled 
        THEN 
          sq_cycled := 'CYCLE';
      ELSE
          sq_cycled := 'NO CYCLE';
      END IF;

      EXECUTE 'ALTER SEQUENCE '   || quote_ident(dest_schema) || '.' || quote_ident(object) 
              || ' INCREMENT BY ' || sq_increment_by
              || ' MINVALUE '     || sq_min_value 
              || ' MAXVALUE '     || sq_max_value
              || ' START WITH '   || sq_start_value
              || ' RESTART '      || sq_min_value 
              || ' CACHE '        || sq_cache_value 
              || sq_cycled || ' ;' ;

      buffer := quote_ident(dest_schema) || '.' || quote_ident(object);
      IF include_recs 
          THEN
              EXECUTE 'SELECT setval( ''' || buffer || ''', ' || sq_last_value || ', ' || sq_is_called || ');' ; 
      ELSE
              EXECUTE 'SELECT setval( ''' || buffer || ''', ' || sq_start_value || ', ' || sq_is_called || ');' ;
      END IF;

    END LOOP;

  -- Create tables 
    FOR object IN
      SELECT TABLE_NAME::text 
        FROM information_schema.tables 
       WHERE table_schema = quote_ident(source_schema)
         AND table_type = 'BASE TABLE'

    LOOP
      buffer := dest_schema || '.' || quote_ident(object);
      EXECUTE 'CREATE TABLE ' || buffer || ' (LIKE ' || quote_ident(source_schema) || '.' || quote_ident(object) 
          || ' INCLUDING ALL)';

      IF include_recs 
        THEN 
        -- Insert records from source table
        EXECUTE 'INSERT INTO ' || buffer || ' SELECT * FROM ' || quote_ident(source_schema) || '.' || quote_ident(object) || ';';
      END IF;

      FOR column_, default_ IN
        SELECT column_name::text, 
               REPLACE(column_default::text, source_schema, dest_schema) 
          FROM information_schema.COLUMNS 
         WHERE table_schema = dest_schema 
           AND TABLE_NAME = object 
           AND column_default LIKE 'nextval(%' || quote_ident(source_schema) || '%::regclass)'
      LOOP
        EXECUTE 'ALTER TABLE ' || buffer || ' ALTER COLUMN ' || column_ || ' SET DEFAULT ' || default_;
      END LOOP;

    END LOOP;

  --  add FK constraint
    FOR qry IN
      SELECT 'ALTER TABLE ' || quote_ident(dest_schema) || '.' || quote_ident(rn.relname) 
                            || ' ADD CONSTRAINT ' || quote_ident(ct.conname) || ' ' || pg_get_constraintdef(ct.oid) || ';'
        FROM pg_constraint ct
        JOIN pg_class rn ON rn.oid = ct.conrelid
       WHERE connamespace = src_oid
         AND rn.relkind = 'r'
         AND ct.contype = 'f'

      LOOP
        EXECUTE qry;

      END LOOP;


  -- Create views 
    FOR object IN
      SELECT table_name::text,
             view_definition 
        FROM information_schema.views
       WHERE table_schema = quote_ident(source_schema)

    LOOP
      buffer := dest_schema || '.' || quote_ident(object);
      SELECT view_definition INTO v_def
        FROM information_schema.views
       WHERE table_schema = quote_ident(source_schema)
         AND table_name = quote_ident(object);

      EXECUTE 'CREATE OR REPLACE VIEW ' || buffer || ' AS ' || v_def || ';' ;

    END LOOP;

  -- Create functions 
    FOR func_oid IN
      SELECT oid
        FROM pg_proc 
       WHERE pronamespace = src_oid

    LOOP      
      SELECT pg_get_functiondef(func_oid) INTO qry;
      SELECT replace(qry, source_schema, dest_schema) INTO dest_qry;
      EXECUTE dest_qry;

    END LOOP;

    RETURN; 

  END;

  $BODY$
    LANGUAGE plpgsql VOLATILE
    COST 100;
  ALTER FUNCTION clone_schema(text, text, boolean)
    OWNER TO postgres;
#+end_src

Woh. That's a lot of SQL, and there are words like CREATE and OR and LOOP in there. Let's step back a bit and go section by section.
** Syntax Preamble
Let's take a quick 
*** Functions
Below is the standard function syntax. Some items are optional, like, you don't need to have an ~OR~ option, you don't need to have any arguments, and you don't have to declare any variables.
#+begin_src sql
  CREATE OR REPLACE FUNCTION demo_func(

      source_schema text
  )
    RETURNS void AS
  $BODY$

  DECLARE
    src_oid          oid;

  BEGIN
  --  ...
  END;
  $BODY$
#+end_src

You can also have anonymous functions, where they operate just like a regular function but lack a name, arguments or the ability to return anything. Anonymous functions are suitable for when you need to do some work, and you need the full power of the PL/pgSQL language (loops, conditionals, logs/errors), but don't need to name it or return anything.

#+begin_src sql
  do $$
  DECLARE
    src_oid oid;
  BEGIN
  -- ...
  END
  $$;
#+end_src

*** For loops!
Like most modern languages, PL/pgSQL has for loops. However, loops can only run within function calls.

So to write a for loop in an anonymous function, it would look something like this:
#+NAME: For loop example
#+begin_src sql :result ouput
  do $$
  BEGIN
   FOR counter IN 1..5 LOOP
     RAISE NOTICE 'Counter: %', counter;
     END LOOP;
   END
  $$;
#+end_src

If you copy and paste this into a PSQL REPL you would get output like below:
#+NAME: Example output
#+begin_src sql
NOTICE:  Counter: 1
NOTICE:  Counter: 2
NOTICE:  Counter: 3
NOTICE:  Counter: 4
NOTICE:  Counter: 5
#+end_src

For loops, in general, can work across an iterable item, be it a range, array, or query results.

That's all there is for unique or semi non-obvious syntax. Hopefully, the rest makes sense.

* Let's break it down
#+BEGIN_COMMENT
Some of my examples are going to include chunks of code wrapped in a function definition. We can easily mimic the calling environment, call special syntax, or get some lovely printout here in org-mode. That means, for the most part, things being functions are an implementation detail and can be safely ignored.
#+END_COMMENT
** Metaprogramming in Postgres
Postgres keeps a table of information about itself and its state, and they call the collection of metadata [[https://www.postgresql.org/docs/13/catalogs.html][systems catalog]]. Generally, these tables are prefixed with ~pg~. For example, ~pg_namespace~ is a table that contains information about all the schema's stored in the database
#+begin_src sql
SELECT * FROM pg_namespace;
#+end_src

#+RESULTS:
|   oid | nspname            | nspowner | nspacl                              |
|-------+--------------------+----------+-------------------------------------|
|    99 | pg_toast           |       10 |                                     |
|    11 | pg_catalog         |       10 | {postgres=UC/postgres,=U/postgres}  |
|  2200 | public             |       10 | {postgres=UC/postgres,=UC/postgres} |
| 13391 | information_schema |       10 | {postgres=UC/postgres,=U/postgres}  |
| 16575 | backup             |       10 |                                     |

** Operating on Schemas
*** Check for schema existence
Knowing about the existence of ~pg_namespace~ gives us the ability to understand the first section of code
#+begin_src sql
-- Check that source_schema exists
    SELECT oid INTO src_oid
      FROM pg_namespace
     WHERE nspname = quote_ident(source_schema);
    IF NOT FOUND
      THEN 
      RAISE NOTICE 'source schema % does not exist!', source_schema;
      RETURN ;
        END IF;

    -- Check that dest_schema does not yet exist
    PERFORM nspname 
      FROM pg_namespace
     WHERE nspname = quote_ident(dest_schema);
    IF FOUND
      THEN 
      RAISE NOTICE 'dest schema % already exists!', dest_schema;
      RETURN ;
    END IF;

    EXECUTE 'CREATE SCHEMA ' || quote_ident(dest_schema) ;
#+end_src

Unfortunately, in its current form, we can't really run that SQL. Let's make it a function so we can normalize the results:
#+NAME: Check that source_schema exists
#+begin_src sql
  CREATE OR REPLACE FUNCTION check_existence(
    source_schema text)
    RETURNS bool AS $BODY$
  BEGIN
  
   PERFORM oid
      FROM pg_namespace
     WHERE nspname = quote_ident(source_schema);
    IF NOT FOUND
    THEN
      RAISE NOTICE 'source schema % does not exist!', source_schema;
      RETURN false;
    ELSE
      RETURN true;
    END IF;
  END;
  $BODY$

  LANGUAGE plpgsql VOLATILE
  COST 100;

  SELECT check_existence('public');
#+end_src

#+RESULTS: Check that source_schema exists
| CREATE FUNCTION |
|-----------------|
| check_existence |
| t               |

We can also check for non existence of a schema
#+NAME: Check that the dest schema doesn't exist
#+begin_src sql
  SELECT check_existence('backup');
#+end_src

#+RESULTS: Check that the dest schema doesn't exist
| check_existence |
|-----------------|
| t               |

*** Creating a schema
Great, now we know that the ~backup~ schema doesn't exist. Let's make one. Luckily creating a schema is pretty easy.
#+begin_src sql
 CREATE SCHEMA backup;
#+end_src

#+RESULTS:
| CREATE SCHEMA |
|---------------|

And we can use our function to verify.
#+begin_src sql
  SELECT check_existence('backup');
#+end_src

#+RESULTS:
| check_existence |
|-----------------|
| t               |

** Sequences
The next step in copying one schema to another is to copy the Sequences
#+begin_src sql
    FOR object IN
      SELECT sequence_name::text 
        FROM information_schema.sequences
        WHERE sequence_schema = quote_ident(source_schema)
    LOOP
      EXECUTE 'CREATE SEQUENCE ' || quote_ident(dest_schema) || '.' || quote_ident(object);
      srctbl := quote_ident(source_schema) || '.' || quote_ident(object);

      EXECUTE 'SELECT last_value, max_value, start_value, increment_by, min_value, cache_value, log_cnt, is_cycled, is_called 
                FROM ' || quote_ident(source_schema) || '.' || quote_ident(object) || ';' 
                INTO sq_last_value, sq_max_value, sq_start_value, sq_increment_by, sq_min_value, sq_cache_value, sq_log_cnt, sq_is_cycled, sq_is_called ; 

      IF sq_is_cycled 
        THEN 
          sq_cycled := 'CYCLE';
      ELSE
          sq_cycled := 'NO CYCLE';
      END IF;

      EXECUTE 'ALTER SEQUENCE '   || quote_ident(dest_schema) || '.' || quote_ident(object) 
              || ' INCREMENT BY ' || sq_increment_by
              || ' MINVALUE '     || sq_min_value 
              || ' MAXVALUE '     || sq_max_value
              || ' START WITH '   || sq_start_value
              || ' RESTART '      || sq_min_value 
              || ' CACHE '        || sq_cache_value 
              || sq_cycled || ' ;' ;

      buffer := quote_ident(dest_schema) || '.' || quote_ident(object);
      IF include_recs 
          THEN
              EXECUTE 'SELECT setval( ''' || buffer || ''', ' || sq_last_value || ', ' || sq_is_called || ');' ; 
      ELSE
              EXECUTE 'SELECT setval( ''' || buffer || ''', ' || sq_start_value || ', ' || sq_is_called || ');' ;
      END IF;

    END LOOP;
#+end_src

*** What is a Sequence
A Sequence is a special table that generates a sequence of numbers. You'll often see a sequence used for generating IDs for tables.
*** Copying Sequence and Values
When copying sequences, we're looking to: 
1. Get all sequence names from the source schema
2. Copy selected sequence names into dest schema
3. Populate them with metadata from source sequences
4. Update destination schema number to match source schema numbers
**** 1. Get All Sequence Names
#+begin_src sql
  SELECT sequence_name::text 
   FROM information_schema.sequences
   WHERE sequence_schema = quote_ident('public')
#+end_src

#+RESULTS:
| sequence_name                         |
|---------------------------------------|
| active_storage_attachments_id_seq     |
| active_storage_blobs_id_seq           |
| active_storage_variant_records_id_seq |
| microposts_id_seq                     |
| relationships_id_seq                  |
| users_id_seq                          |

Before we move on, let's make sure our new schema doesn't have any sequences

#+begin_src sql
  SELECT sequence_name::text 
   FROM information_schema.sequences
   WHERE sequence_schema = quote_ident('backup')
#+end_src

**** 2. Create Sequence
Typically this would look something like
#+begin_src sql
  FOR object IN
    SELECT sequence_name::text 
           FROM information_schema.sequences
           WHERE sequence_schema = quote_ident(source_schema)
  LOOP
    EXECUTE 'CREATE SEQUENCE ' || quote_ident(dest_schema) || '.' || quote_ident(object);
    srctbl := quote_ident(source_schema) || '.' || quote_ident(object);
  END LOOP;
#+end_src

There can be many sequences in a schema, so let's zoom in on one sequence and follow it through the process.
From the code above, where you see ~object~, we will replace it with ~microposts_id_seq'~, one of the values from the above select statement.
#+begin_src sql
  CREATE SEQUENCE backup.microposts_id_seq;
#+end_src

And let's take a look at what we made
#+begin_src sql
  SELECT * FROM public.microposts_id_seq;
#+end_src

#+RESULTS:
| last_value | log_cnt | is_called |
|------------+---------+-----------|
|        300 |      30 | t         |

We made a table that stores values for last_value, log_cnt[fn:1], and is_called[fn:2].

**** 3. Copy Sequence Values
Now we're going to fake it a little bit to see what the next statement is doing more easily.

We can translate:
#+begin_src sql
    EXECUTE 'SELECT last_value, max_value, start_value, increment_by, min_value, cache_value, log_cnt, is_cycled, is_called 
    FROM ' || quote_ident('public') || '.' || quote_ident(object) || ';' 
    INTO sq_last_value, sq_max_value, sq_start_value, sq_increment_by, sq_min_value, sq_cache_value, sq_log_cnt, sq_is_cycled, sq_is_called ; 
#+end_src

To:
#TODO: Update to postgres 10
#+begin_src sql
  SELECT last_value AS sq_last_value, max_value AS sq_max_value, start_value AS sq_start_value, increment_by AS sq_increment_by,
         min_value AS sq_min_value, cache_value AS sq_cache_value, log_cnt AS sq_log_cnt, is_cycled AS sq_is_cycled,
         is_called AS sq_is_called
  FROM public.user_id_seq;
#+end_src

Now because of how SQL works, we have to convert data. So we translate the value ~sq_is_cycled~ from a boolean to a string.

#+begin_src sql
    IF sq_is_cycled
      THEN 
        sq_cycled := 'CYCLE';
    ELSE
        sq_cycled := 'NO CYCLE';
    END IF;
#+end_src

If we could run that code, we would see that users_id_seq is not cycled, and we get ~'NO CYCLE'~.

So now we want to copy over the data from ~public.microposts_id_seq~ to ~backup.microposts_id_seq~
#+begin_src sql
    ALTER SEQUENCE backup.microposts_id_seq
            INCREMENT BY 1 
            MINVALUE     1
            MAXVALUE     9223372036854775807
            START WITH   1
            RESTART      1
            CACHE        1
            NO CYCLE;
#+end_src

**** 4. Update sequence to match current values
Then because we're cloning both meta information and records themselves, we want to make sure our sequence values line up with the ~public~'s sequence values.
#+begin_src sql
SELECT setval( 'backup.microposts_id_seq', 300, true);
#+end_src

#+RESULTS:
| setval |
|--------|
|    300 |

***** Let's quickly verify our work
If we call nextval on ~public.microposts_id_seq~ and ~backup.microposts_id_seq~ they should produce the same results.

#+begin_src sql
SELECT nextval( 'public.microposts_id_seq');
#+end_src

#+RESULTS:
| nextval |
|---------|
|     301 |

#+begin_src sql
SELECT nextval( 'backup.microposts_id_seq');
#+end_src

#+RESULTS:
| nextval |
|---------|
|     301 |

**** Playground :TODO:VALIDATE:FIX:
And now we just do that like... 50 more times.

#+begin_src sql
  do $$
  DECLARE
  source_schema text;
  dest_schema text;
  srctbl text;
  object oid;
  BEGIN
  source_schema := 'dev';
  dest_schema := 'demo';
  FOR object IN
        SELECT sequence_name::text 
          FROM information_schema.sequences
          WHERE sequence_schema = quote_ident(source_schema)
      LOOP
        EXECUTE 'CREATE SEQUENCE ' || quote_ident(dest_schema) || '.' || quote_ident(object);
        srctbl := quote_ident(source_schema) || '.' || quote_ident(object);
  
        EXECUTE 'SELECT last_value, max_value, start_value, increment_by, min_value, cache_value, log_cnt, is_cycled, is_called 
                  FROM ' || quote_ident(source_schema) || '.' || quote_ident(object) || ';' 
                  INTO sq_last_value, sq_max_value, sq_start_value, sq_increment_by, sq_min_value, sq_cache_value, sq_log_cnt, sq_is_cycled, sq_is_called ; 
  
        IF sq_is_cycled 
          THEN 
            sq_cycled := 'CYCLE';
        ELSE
            sq_cycled := 'NO CYCLE';
        END IF;
  
        EXECUTE 'ALTER SEQUENCE '   || quote_ident(dest_schema) || '.' || quote_ident(object) 
                || ' INCREMENT BY ' || sq_increment_by
                || ' MINVALUE '     || sq_min_value 
                || ' MAXVALUE '     || sq_max_value
                || ' START WITH '   || sq_start_value
                || ' RESTART '      || sq_min_value 
                || ' CACHE '        || sq_cache_value 
                || sq_cycled || ' ;' ;
  
        buffer := quote_ident(dest_schema) || '.' || quote_ident(object);
        IF include_recs 
            THEN
                EXECUTE 'SELECT setval( ''' || buffer || ''', ' || sq_last_value || ', ' || sq_is_called || ');' ; 
        ELSE
                EXECUTE 'SELECT setval( ''' || buffer || ''', ' || sq_start_value || ', ' || sq_is_called || ');' ;
        END IF;
  
      END LOOP;
  END
  $$;
#+end_src

#+RESULTS:
|---|

** Tables
Now, with the next section of code, we want to copy tables and their associated data.

#+begin_src sql
    FOR object IN
      SELECT TABLE_NAME::text 
        FROM information_schema.tables 
       WHERE table_schema = quote_ident(source_schema)
         AND table_type = 'BASE TABLE'

    LOOP
      buffer := dest_schema || '.' || quote_ident(object);
      EXECUTE 'CREATE TABLE ' || buffer || ' (LIKE ' || quote_ident(source_schema) || '.' || quote_ident(object) 
          || ' INCLUDING ALL)';

      IF include_recs 
        THEN 
        -- Insert records from source table
        EXECUTE 'INSERT INTO ' || buffer || ' SELECT * FROM ' || quote_ident(source_schema) || '.' || quote_ident(object) || ';';
      END IF;

      FOR column_, default_ IN
        SELECT column_name::text, 
               REPLACE(column_default::text, source_schema, dest_schema) 
          FROM information_schema.COLUMNS 
         WHERE table_schema = dest_schema 
           AND TABLE_NAME = object 
           AND column_default LIKE 'nextval(%' || quote_ident(source_schema) || '%::regclass)'
      LOOP
        EXECUTE 'ALTER TABLE ' || buffer || ' ALTER COLUMN ' || column_ || ' SET DEFAULT ' || default_;
      END LOOP;

    END LOOP;
#+end_src


*** Copying table structure and data
This requires us to:
1. Get all the tables of interest
2. Create the tables in the new schema
3. Copy data from the source schema's tables into the new schema's tables
4. Update Default/Sequence values for appropriate columns

**** 1. Get all tables
We want to iterate over all the tables in a schema. But how do we get that information? Luckily, Postgres has meta-programming facilities based around schema's called [[https://www.postgresql.org/docs/current/information-schema.html][information_schema]] which has a [[https://www.postgresql.org/docs/13/sql-createview.html][view]] specifically for [[https://www.postgresql.org/docs/current/infoschema-tables.html][tables]].

In short if we run a command like below, we can get a list of all table names we want to operate on.
#+begin_src sql
  -- FOR OBJECT In
      SELECT TABLE_NAME::text 
        FROM information_schema.tables 
       WHERE table_schema = 'public'
         AND table_type = 'BASE TABLE'
#+end_src

#+RESULTS:
| table_name                     |
|--------------------------------|
| active_storage_variant_records |
| users                          |
| microposts                     |
| relationships                  |
| active_storage_blobs           |
| active_storage_attachments     |
| schema_migrations              |
| ar_internal_metadata           |

**** 2. Copying table structure

Like in sequences, we're going to step through copying one table as an example of how it works across the entire system. Let's operate on the ~microposts~ table.

It's surprisingly simple to copy table structures across schemas. All we need are two new pieces of syntax: LIKE and INCLUDING. When doing a CREATE table operation, this means copy this table with X columns, indexes, and constraints.
#+begin_src sql
CREATE TABLE backup.microposts (LIKE public.microposts INCLUDING ALL);
#+end_src

#+RESULTS:
| CREATE TABLE |
|--------------|

We can verify that this works by seeing that the table is empty when we query backup for microposts.
 
#+begin_src sql
SELECT id, content FROM backup.microposts
#+end_src

**** 3. Copy Data
Copying data is one of the least complicated interactions we have. It's just a combination of INSERT and SELECT operations.

#+NAME: Copying data using select and insert
#+begin_src sql
INSERT INTO backup.microposts SELECT * FROM public.microposts;
#+end_src

#+RESULTS: Copying data using select and insert
| INSERT 0 300 |
|--------------|

We can admire our handiwork by using a SELECT and a RIGHT JOIN statement. 

ðŸ˜²

Shocking, I know.
#+begin_src sql
SELECT public.microposts.content as public_content, public.microposts.id as public_id,
       backup.microposts.content as backup_content, backup.microposts.id as backup_id
FROM backup.microposts
RIGHT JOIN public.microposts on backup.microposts.id = public.microposts.id LIMIT 10;
#+end_src

#+RESULTS:
| public_content                         | public_id | backup_content                         | backup_id |
|----------------------------------------+-----------+----------------------------------------+-----------|
| Minus officia perspiciatis hic beatae. |         1 | Minus officia perspiciatis hic beatae. |         1 |
| Minus officia perspiciatis hic beatae. |         2 | Minus officia perspiciatis hic beatae. |         2 |
| Minus officia perspiciatis hic beatae. |         3 | Minus officia perspiciatis hic beatae. |         3 |
| Minus officia perspiciatis hic beatae. |         4 | Minus officia perspiciatis hic beatae. |         4 |
| Minus officia perspiciatis hic beatae. |         5 | Minus officia perspiciatis hic beatae. |         5 |
| Minus officia perspiciatis hic beatae. |         6 | Minus officia perspiciatis hic beatae. |         6 |
| Sed ab sed voluptas sit.               |         7 | Sed ab sed voluptas sit.               |         7 |
| Sed ab sed voluptas sit.               |         8 | Sed ab sed voluptas sit.               |         8 |
| Sed ab sed voluptas sit.               |         9 | Sed ab sed voluptas sit.               |         9 |
| Sed ab sed voluptas sit.               |        10 | Sed ab sed voluptas sit.               |        10 |

**** 4. Update Default/Sequence values for columns
When we created the ~backup.microposts~ table based off of the ~public.microposts~ table it copied everything, metadata included, word for word. This causes problems when we need to use our sequences from earlier. So we need to search through the metadata of the table and look for columns with a default value that uses sequences and replaces the inner text from referencing ~public~ to reference ~backup~.

We can generate a query that performs this for us
#+begin_src sql
        SELECT column_name::text, 
               REPLACE(column_default::text, 'public', 'backup'),
               column_default::text
          FROM information_schema.COLUMNS 
         WHERE table_schema = 'backup'
           AND TABLE_NAME = 'microposts'
           AND column_default LIKE 'nextval(%public%::regclass)'
#+end_src

We can then use this information to update our apps table to reference the new sequences we generated.
#+begin_src sql
ALTER TABLE backup.microposts ALTER COLUMN id SET DEFAULT nextval('backup.microposts_id_seq'::regclass);
#+end_src

And if you wonder what happens when we call nextval('backup.microposts_id_seq'::regclass), you can play with it below. Essentially it generates a monotonically increasing number, perfect for an object id.
#+begin_src sql
SELECT nextval('public.microposts_id_seq'::regclass);
#+end_src

**** Playground  :TODO:VALIDATE:
#+begin_src sql
DO $$
    source_schema := 'dev'
    dest_schema := 'demo'
    FOR object IN
      SELECT TABLE_NAME::text 
        FROM information_schema.tables 
       WHERE table_schema = quote_ident(source_schema)
         AND table_type = 'BASE TABLE'

    LOOP
      buffer := dest_schema || '.' || quote_ident(object);
      EXECUTE 'CREATE TABLE ' || buffer || ' (LIKE ' || quote_ident(source_schema) || '.' || quote_ident(object) 
          || ' INCLUDING ALL)';

      IF include_recs 
        THEN 
        -- Insert records from source table
        EXECUTE 'INSERT INTO ' || buffer || ' SELECT * FROM ' || quote_ident(source_schema) || '.' || quote_ident(object) || ';';
      END IF;

      FOR column_, default_ IN
        SELECT column_name::text, 
               REPLACE(column_default::text, source_schema, dest_schema) 
          FROM information_schema.COLUMNS 
         WHERE table_schema = dest_schema 
           AND TABLE_NAME = object 
           AND column_default LIKE 'nextval(%' || quote_ident(source_schema) || '%::regclass)'
      LOOP
        EXECUTE 'ALTER TABLE ' || buffer || ' ALTER COLUMN ' || column_ || ' SET DEFAULT ' || default_;
      END LOOP;
    END LOOP;
$$ END;
#+end_src

** Foreign Key Constraints
Now we'll be concerned about is foreign key constraints. This helps define and validate relationships between tables.

#+begin_src sql
    FOR qry IN
      SELECT 'ALTER TABLE ' || quote_ident(dest_schema) || '.' || quote_ident(rn.relname) 
                            || ' ADD CONSTRAINT ' || quote_ident(ct.conname) || ' ' || pg_get_constraintdef(ct.oid) || ';'
        FROM pg_constraint ct
        JOIN pg_class rn ON rn.oid = ct.conrelid
       WHERE connamespace = src_oid
         AND rn.relkind = 'r'
         AND ct.contype = 'f'

      LOOP
        EXECUTE qry;

      END LOOP;
#+end_src
*** Copying Constraints
1. Go over all constraints for source schema
2. Generate a query to create the same constraint on the destination schema
3. Execute all the queries

**** 0. Get src schema oid
We only need to get this 
#+begin_src sql
    SELECT oid
      FROM pg_namespace
     WHERE nspname = quote_ident('public');
#+end_src

#+RESULTS:
|  oid |
|------|
| 2200 |

**** 1. Get all constraints for source schema
Postgres has a catalogue called [[https://www.postgresql.org/docs/current/catalog-pg-constraint.html][pg_constraint]] that contains meta-information around all the constraints (foreign_key, primary_key, and exclusion) across the database. Unfortunately, that table is not sufficient to generate our query; we also need access to [[https://www.postgresql.org/docs/current/catalog-pg-class.html][pg_class]] which is a catalogue that keeps meta-information on anything that has a column in Postgres.

In ~pg_constraint~ it a has a column call contype, that describes the type on constraint that the row describes. Ex:
  + c = check constraint
  + f = foreign key constraint
  + p = primary key constraint
  + u = unique constraint
  + t = constraint trigger
  + x = exclusion constraint

So because we're looking for foreign key constraints, we can limit our query to ~ct.contype = 'f'~.

For ~pg_class~, it has a column called relkind that describes the kind of relations that row describes. Ex:
  + r = ordinary table
  + i = index
  + S = sequence
  + t = TOAST table
  + v = view
  + m = materialized view
  + c = composite type
  + f = foreign table
  + p = partitioned table
  + I = partitioned index

Because we've only really copied over tables, that's all we really care about for kinds of relation ~rn.relkind = 'r'~.

Putting this all together we'd get a query like:
#+NAME: Constraints Query
#+begin_src sql
  SELECT rn.relname, ct.conname, ct.oid
    FROM pg_constraint ct
    JOIN pg_class rn ON rn.oid = ct.conrelid
    WHERE connamespace = (SELECT oid
                          FROM pg_namespace
                          WHERE nspname = quote_ident('public'))
     AND rn.relkind = 'r'
     AND ct.contype = 'f';
#+end_src

#+RESULTS: Constraints Query
| relname                        | conname             |   oid |
|--------------------------------+---------------------+-------|
| active_storage_attachments     | fk_rails_c3b3935057 | 16450 |
| active_storage_variant_records | fk_rails_993965df05 | 16455 |
| microposts                     | fk_rails_558c81314b | 16460 |

**** 2. Generate a query to create constraints

Postgres has a function, [[https://www.postgresql.org/docs/13/functions-info.html#FUNCTIONS-INFO-CATALOG-TABLE][pg_get_constraintdef,]] that can generate a constraint definition based on an object id.

For example, if we take a row from the constraints query above, we get an OID of ~18403~.
#+NAME: Example row from constraints query
#+BEGIN_EXAMPLE
| relname                | conname             |   oid |
|------------------------+---------------------+-------|
| microposts             | fk_rails_d296c622dc | 16460 |
#+END_EXAMPLE

If we run a select statement on that function...
#+NAME: Sample constraints definition.
#+begin_src sql
SELECT pg_get_constraintdef(16460)
#+end_src

We get the following definition:
#+RESULTS: Sample constraints definition.
| pg_get_constraintdef                       |
|--------------------------------------------|
| FOREIGN KEY (user_id) REFERENCES users(id) |

We can then put this information with the Constraints Query to generate the query for us:
#+begin_src sql
SELECT 'ALTER TABLE ' || quote_ident('backup') || '.' || quote_ident(rn.relname) 
       || ' ADD CONSTRAINT ' || quote_ident(ct.conname) || ' ' || pg_get_constraintdef(ct.oid) || ';'
       FROM pg_constraint ct
       JOIN pg_class rn ON rn.oid = ct.conrelid
       WHERE connamespace = (SELECT oid
                             FROM pg_namespace
                             WHERE nspname = quote_ident('public'))
         AND rn.relkind = 'r'
         AND ct.contype = 'f'
       LIMIT 1;
#+end_src

#+RESULTS:
| ?column?                                                                                                                                    |
|---------------------------------------------------------------------------------------------------------------------------------------------|
|  |

**** 3. Execute generate queries
Now, we can use a select statement to run a string as a query
#+begin_src sql
  SELECT 'ALTER TABLE backup.active_storage_attachments ADD CONSTRAINT fk_rails_c3b3935057 FOREIGN KEY (blob_id) REFERENCES active_storage_blobs(id);'
#+end_src

**** Playground :TODO:VALIDATE:
#+begin_src sql
DO $$
    FOR qry IN
      SELECT 'ALTER TABLE ' || quote_ident(dest_schema) || '.' || quote_ident(rn.relname) 
                            || ' ADD CONSTRAINT ' || quote_ident(ct.conname) || ' ' || pg_get_constraintdef(ct.oid) || ';'
        FROM pg_constraint ct
        JOIN pg_class rn ON rn.oid = ct.conrelid
       WHERE connamespace = src_oid
         AND rn.relkind = 'r'
         AND ct.contype = 'f'

      LOOP
        EXECUTE qry;

      END LOOP;
END $$;
#+end_src

** Views
A [[https://www.postgresql.org/docs/14/tutorial-views.html][view]] in SQL is a way of saving query a query that you expect to be running over and over again.

#+begin_src sql
    FOR object IN
      SELECT table_name::text
        FROM information_schema.views
       WHERE table_schema = quote_ident(source_schema)

    LOOP
      buffer := dest_schema || '.' || quote_ident(object);
      SELECT view_definition INTO v_def
        FROM information_schema.views
       WHERE table_schema = quote_ident(source_schema)
         AND table_name = quote_ident(object);

         EXECUTE 'CREATE OR REPLACE VIEW ' || buffer || ' AS ' || v_def || ';' ;

    END LOOP;
#+end_src

If you have a database with views the steps would be as follow:
1. Loops over each view in ~information_schema.views~
2. Use the view definition, that is stored in the view catalog, to define the view in the destination schema
   
Aye, but there's the rub. Our data set is a bit basic and doesn't include view and functions. So we'll build some as we go.

*** Precursor
But before we can do that let's be absolutely sure that we don't have any views stored in our view catalog.
#+begin_src sql
       SELECT table_name::text
        FROM information_schema.views
       WHERE table_schema = quote_ident('public')
#+end_src

*** Creating our view

In our example we'll create a view for all microposts created by a certain user.

#+NAME: Creating a new view
#+begin_src sql
  CREATE VIEW first_users_posts AS
    SELECT content, microposts.created_at as created_at, name
        FROM microposts, users
        WHERE users.id = (SELECT id FROM users LIMIT 1)
#+end_src

Now, lets validate that it works
#+NAME: Test our view
#+begin_src sql
SELECT * FROM first_users_posts LIMIT 10
#+end_src

#+RESULTS:
| content                                | created_at                 | name         |
|----------------------------------------+----------------------------+--------------|
| Minus officia perspiciatis hic beatae. | 2021-11-23 05:52:47.384011 | Example User |
| Minus officia perspiciatis hic beatae. | 2021-11-23 05:52:47.399006 | Example User |
| Minus officia perspiciatis hic beatae. | 2021-11-23 05:52:47.419306 | Example User |
| Minus officia perspiciatis hic beatae. | 2021-11-23 05:52:47.438467 | Example User |
| Minus officia perspiciatis hic beatae. | 2021-11-23 05:52:47.456818 | Example User |
| Minus officia perspiciatis hic beatae. | 2021-11-23 05:52:47.475834 | Example User |
| Sed ab sed voluptas sit.               | 2021-11-23 05:52:47.492691 | Example User |
| Sed ab sed voluptas sit.               | 2021-11-23 05:52:47.506167 | Example User |
| Sed ab sed voluptas sit.               | 2021-11-23 05:52:47.520004 | Example User |
| Sed ab sed voluptas sit.               | 2021-11-23 05:52:47.533737 | Example User |

*** Collecting the views
Now with all the dirty work done, we need to loop over all of the views in our catalog. Luckily we've already seen the primary tool for that. Let's just limit our selection to one, so it's easier to go through this step by step.

#+NAME: Select one view
#+begin_src sql
       SELECT table_name::text
        FROM information_schema.views
       WHERE table_schema = quote_ident('public')
       LIMIT 1
#+end_src

#+RESULTS:
| table_name        |
|-------------------|
| first_users_posts |

*** Copying views
Great, we've got a view name. Now we can use that name to build up the name of the view for the destination schema

#+NAME: Naming the view
#+begin_src sql
SELECT 'backup' || '.' || quote_ident('first_users_posts');
#+end_src

Now that we've generated the name we need to get the view definition
#+begin_src sql
      SELECT view_definition
        FROM information_schema.views
       WHERE table_schema = quote_ident('public')
         AND table_name = quote_ident('first_users_posts');
#+end_src

And then, finally, we can use these pieces of information to copy the view.

#+begin_src sql
EXECUTE 'CREATE OR REPLACE VIEW ' || 'backup' || '.' ||
        quote_ident('first_users_posts') || ' AS ' ||
        (SELECT view_definition
         FROM information_schema.views
         WHERE table_schema = quote_ident('public')
         AND table_name = quote_ident('first_users_posts')) || ';'
#+end_src

#+RESULTS:
|---|


** Functions
We don't have schema specific functions, all of our functions are used from the ~shared_extensions~ schema, so we don't really need to copy this either.
** Footnotes
[fn:1]Why log_cnt exists is kind of interesting. https://stackoverflow.com/a/66458412
[fn:2]is_called is boolean that modifies what setval returns. https://www.postgresql.org/docs/14/functions-sequence.html
